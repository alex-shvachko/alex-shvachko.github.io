<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Projects — Stay Real</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800;900&family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
  <style>
    body{margin:0; background:#ffffff; color:#111; overflow:hidden;
      font-family: 'Outfit', system-ui, -apple-system, sans-serif;
      -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;}
    canvas#stage{position:fixed; inset:0; width:100vw; height:100vh; display:block; z-index:1;}
    .hint{position:fixed; left:50%; bottom:26px; transform:translateX(-50%);
      background:rgba(0,0,0,.04); border:1px solid rgba(0,0,0,.07); color:#333;
      padding:8px 12px; border-radius:12px; font-size:12px; letter-spacing:.2px; z-index:10;
      transition: opacity 0.3s ease;}
    .skill-button {
      position: fixed;
      transform: translate(-50%, -50%);
      background: #111;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 30px;
      font-family: 'Outfit', sans-serif;
      font-weight: 500;
      font-size: 16px;
      cursor: pointer;
      opacity: 0;
      pointer-events: none;
      z-index: 2;
      transition: all 0.6s cubic-bezier(0.2, 0.8, 0.3, 1.1);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      scale: 0.5;
    }
    .skill-button.visible {
      opacity: 1;
      pointer-events: auto;
      scale: 1;
    }
    .nav {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
    }
    .links {
      display: flex;
      gap: 12px;
    }
    .pill {
      padding: 8px 16px;
      background: rgba(255,255,255,0.9);
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 20px;
      text-decoration: none;
      color: #333;
      font-size: 14px;
      transition: all 0.2s ease;
    }
    .pill:hover {
      background: rgba(0,0,0,0.05);
    }
    .pill.active {
      background: #111;
      color: white;
    }
    footer {
      position: fixed;
      bottom: 20px;
      right: 20px;
      font-size: 12px;
      color: rgba(0,0,0,0.6);
      z-index: 10;
    }
  </style>
</head>
<body>
  <canvas id="stage" aria-label="Interactive cube particle field"></canvas>
  <div class="hint" id="hint">Move your cursor to the center to transform the cube • Tap center on mobile</div>

  <header>
    <nav class="nav">
      <div class="links">
        <a class="pill" href="../">Home</a>
        <a class="pill active" href="../projects/">Projects</a>
        <a class="pill" href="../services/">Services</a>
      </div>
    </nav>
  </header>
  <footer>
    © <span id="year">2025</span> Alex Shvachko — Stay Real.
  </footer>

  <script>
(function(){
  const cvs = document.getElementById('stage');
  const ctx = cvs.getContext('2d');
  const hint = document.getElementById('hint');
  const DPR = Math.min(devicePixelRatio || 1, 2);

  let W=0, H=0, last=performance.now();
  let GRID = 105;
  let SIZE = 0;
  let CX=0, CY=0;
  let CELL=0;
  let transformTriggered = false;
  let transformProgress = 0;
  let transformComplete = false;
  let distortionAmount = 0;

  const buttonLabels = [
    'Data Science', 'Machine Learning', 'Data Engineering',
    'Automations', 'AI Engineering', 'AI Art'
  ];
  let buttons = [];

  const particles = [];
  // Track velocity to bias swirl direction/intensity
  const mouse = {x:0, y:0, active:false, vx:0, vy:0, px:0, py:0};

  function createButtons() {
    // Remove existing buttons
    buttons.forEach(btn => btn.element && btn.element.remove());
    buttons = [];
    
    const angleStep = (Math.PI * 2) / buttonLabels.length;
    const radius = Math.min(W, H) * 0.25;
    
    buttonLabels.forEach((label, i) => {
      const btn = document.createElement('button');
      btn.className = 'skill-button';
      btn.textContent = label;
      document.body.appendChild(btn);
      
      const angle = i * angleStep - Math.PI/2;
      const x = CX + Math.cos(angle) * radius;
      const y = CY + Math.sin(angle) * radius;
      
      btn.style.left = (x/DPR) + 'px';
      btn.style.top = (y/DPR) + 'px';
      
      buttons.push({
        element: btn,
        x: x,
        y: y,
        angle: angle,
        radius: radius
      });
    });
  }

  function fit(){
    W = cvs.width  = Math.floor(innerWidth * DPR);
    H = cvs.height = Math.floor(innerHeight * DPR);
    cvs.style.width = innerWidth+'px';
    cvs.style.height= innerHeight+'px';

    const S = Math.floor(Math.min(W,H) * 0.34);
    SIZE = S; 
    CX = Math.floor(W*0.5); 
    CY = Math.floor(H*0.5);

    GRID = Math.max(60, Math.min(150, Math.round(S/6)));
    CELL = S / GRID;
    
    if (!transformTriggered) {
      createButtons();
    }

    // Rebuild particles only if transform hasn't been triggered
    if (!transformTriggered) {
      particles.length = 0;
      const startX = CX - S/2 + CELL/2;
      const startY = CY - S/2 + CELL/2;
      for(let gy=0; gy<GRID; gy++){
        for(let gx=0; gx<GRID; gx++){
          const hx = startX + gx*CELL;
          const hy = startY + gy*CELL;
          particles.push({ 
            x: hx, 
            y: hy, 
            vx: 0, 
            vy: 0, 
            homeX: hx, 
            homeY: hy, 
            mass: 0.8 + Math.random()*0.6,
            targetButton: null,
            flying: false,
            disappeared: false
          });
        }
      }
    }
  }

  function onMove(e){
    if (transformComplete) return;
    
    const cx = (e.touches? e.touches[0].clientX : e.clientX) * DPR;
    const cy = (e.touches? e.touches[0].clientY : e.clientY) * DPR;

    // smoothed velocity for direction-aware swirl
    mouse.vx = (cx - mouse.px) * 0.6 + mouse.vx * 0.4;
    mouse.vy = (cy - mouse.py) * 0.6 + mouse.vy * 0.4;
    mouse.px = cx; 
    mouse.py = cy;

    mouse.x = cx; 
    mouse.y = cy; 
    mouse.active = true;
  }

  function triggerTransform() {
    transformTriggered = true;
    hint.style.opacity = '0';
    
    // Show buttons immediately
    buttons.forEach((btn, i) => {
      setTimeout(() => {
        btn.element.classList.add('visible');
      }, i * 100);
    });

    // Assign each particle to a button and start flying
    particles.forEach((p, i) => {
      const buttonIndex = Math.floor(Math.random() * buttons.length);
      p.targetButton = buttons[buttonIndex];
      p.flying = true;
      
      // Add some initial velocity towards the target
      const dx = p.targetButton.x - p.x;
      const dy = p.targetButton.y - p.y;
      const dist = Math.hypot(dx, dy) || 1;
      const speed = 2 + Math.random() * 3;
      p.vx = (dx / dist) * speed;
      p.vy = (dy / dist) * speed;
    });
  }

  addEventListener('mousemove', onMove, {passive:true});
  addEventListener('touchstart', onMove, {passive:true});
  addEventListener('resize', fit);

  // Helper: distance from point to the cube rect (0 if inside)
  function distToCube(px, py){
    const dx = Math.max(Math.abs(px - CX) - SIZE/2, 0);
    const dy = Math.max(Math.abs(py - CY) - SIZE/2, 0);
    return Math.hypot(dx, dy);
  }

  function step(dt){
    // Update distortion based on proximity to cube & mouse speed (only if not transformed)
    if (!transformTriggered) {
      if (mouse.active) {
        const d = distToCube(mouse.x, mouse.y);
        const limit = SIZE * 0.50; // influence range outside the cube
        const prox = Math.max(0, 1 - d / limit); // 1 inside / near, 0 far
        const speed = Math.hypot(mouse.vx, mouse.vy);
        const speedBoost = Math.min(1, speed / (28 * DPR)); // extra swirl when gliding
        const target = Math.max(0, Math.min(1, prox * 0.9 + speedBoost * 0.35));
        distortionAmount += (target - distortionAmount) * 0.15; // smooth lerp
      } else {
        distortionAmount *= 0.92;
      }
    }

    if (!transformTriggered) {
      // Check if cursor is within 40px of cube center for transformation
      if (mouse.active) {
        const dToCenter = Math.hypot(mouse.x - CX, mouse.y - CY);
        if (dToCenter <= 40 * DPR) {
          triggerTransform();
        }
      }
      return;
    }

    transformProgress = Math.min(1, transformProgress + dt * 0.008);

    for(let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      if (p.disappeared) continue;

      if (p.flying && p.targetButton) {
        // Fly towards the assigned button
        const dx = p.targetButton.x - p.x;
        const dy = p.targetButton.y - p.y;
        const dist = Math.hypot(dx, dy) || 1;
        
        if (dist < 15 * DPR) {
          // Close enough to button - disappear
          p.disappeared = true;
          continue;
        }

        // Accelerate towards target
        const force = 0.08;
        p.vx += (dx / dist) * force;
        p.vy += (dy / dist) * force;
        
        // Add some randomness for organic movement
        p.vx += (Math.random() - 0.5) * 0.5;
        p.vy += (Math.random() - 0.5) * 0.5;
        
        // Apply velocity with some damping
        p.vx *= 0.98;
        p.vy *= 0.98;
        p.x += p.vx * (dt * 0.1);
        p.y += p.vy * (dt * 0.1);
      }
    }

    // Check if all particles have disappeared
    const remainingParticles = particles.filter(p => !p.disappeared);
    if (remainingParticles.length === 0 && !transformComplete) {
      transformComplete = true;
    }
  }

  function draw(){
    ctx.clearRect(0,0,W,H);

    if (transformComplete) return;

    if (!transformTriggered) {
      // Draw solid cube with strong fish-eye + swirl distortion and guaranteed hole at cursor
      ctx.save();
      ctx.fillStyle = '#111111';
      
      if (distortionAmount > 0 && mouse.active) {
        const gridRes = 32; // finer sampling => smoother effect
        const cellW = SIZE / gridRes;
        const cellH = SIZE / gridRes;
        const startX = CX - SIZE/2 + cellW/2;
        const startY = CY - SIZE/2 + cellH/2;

        const maxEffect = SIZE * 0.80;                           // radius of influence
        const baseHole  = Math.max(12 * DPR, SIZE * 0.12);       // minimum white hole
        const hole      = baseHole + distortionAmount * SIZE * 0.10;

        for (let gy = 0; gy < gridRes; gy++) {
          for (let gx = 0; gx < gridRes; gx++) {
            const ox = startX + gx * cellW;
            const oy = startY + gy * cellH;

            const dx = ox - mouse.x;
            const dy = oy - mouse.y;
            const dist = Math.hypot(dx, dy) + 1e-4;

            // outside influence => draw normally
            if (dist > maxEffect) {
              ctx.fillRect(ox - cellW/2, oy - cellH/2, cellW, cellH);
              continue;
            }

            // t: 0 at cursor, 1 at edge
            const t = dist / maxEffect;
            const focus = 1 - t; // 1 near the cursor

            // Swirl angle (stronger near cursor). Direction uses 2D cross with mouse velocity.
            const baseTheta = focus * focus * (0.95 * Math.max(0.35, distortionAmount)); // up to ~0.95 rad
            const cross = mouse.vx * dy - mouse.vy * dx; // sign of rotation
            const sign = cross >= 0 ? 1 : -1;
            const theta = baseTheta * sign;

            const cos = Math.cos(theta);
            const sin = Math.sin(theta);

            // rotate around cursor (swirl)
            let rx = cos * dx - sin * dy;
            let ry = sin * dx + cos * dy;

            // fisheye magnification (pushes outwards, creating a gap)
            const radialGain = 1 + focus * focus * (1.05 + 1.25 * distortionAmount); // >1 near center
            rx *= radialGain;
            ry *= radialGain;

            const nx = mouse.x + rx;
            const ny = mouse.y + ry;

            // guaranteed white space around cursor
            if (Math.hypot(nx - mouse.x, ny - mouse.y) < hole) continue;

            // shrink cells near cursor => ring of orbiting "particles"
            const scale = Math.max(0.25, Math.min(1, 1 - focus * (0.75 + 0.5 * distortionAmount)));

            ctx.save();
            ctx.translate(nx, ny);
            ctx.scale(scale, scale);
            ctx.fillRect(-cellW/2, -cellH/2, cellW, cellH);
            ctx.restore();
          }
        }
      } else {
        // Normal solid cube
        ctx.fillRect(CX - SIZE/2, CY - SIZE/2, SIZE, SIZE);
      }
      
      ctx.restore();
    } else {
      // Draw individual particles during transformation
      ctx.fillStyle = '#111111';
      
      for(const p of particles) {
        if (p.disappeared) continue;
        
        let opacity = 1;
        if (p.flying && p.targetButton) {
          // Fade out as particle approaches button
          const dx = p.targetButton.x - p.x;
          const dy = p.targetButton.y - p.y;
          const dist = Math.hypot(dx, dy);
          opacity = Math.max(0, Math.min(1, dist / (30 * DPR)));
        }
        
        if (opacity > 0) {
          ctx.save();
          ctx.globalAlpha = opacity;
          const particleSize = CELL * 0.8;
          const x = Math.round(p.x - particleSize/2);
          const y = Math.round(p.y - particleSize/2);
          const size = Math.ceil(particleSize);
          ctx.fillRect(x, y, size, size);
          ctx.restore();
        }
      }
    }
  }

  function frame(now){
    const dt = Math.min(60, now - last); 
    last = now;
    step(dt); 
    draw(); 
    requestAnimationFrame(frame);
  }

  fit(); 
  requestAnimationFrame(frame);
})();
  </script>
</body>
</html>
